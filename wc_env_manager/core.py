""" Tools for managing computing environments for whole-cell modeling

* Pull Docker image
* Create Docker container

    * Copy configuration files (e.g. ``.gitconfig``) and authentication keys (e.g. GitHub SSH key)
      into container
    * Download and install WC models and tools into container
    * Create volumes to load local versions of models and tools into container
    
* Run model/tool in Docker container
* Stop Docker container
* Delete Docker container

:Author: Arthur Goldberg <Arthur.Goldberg@mssm.edu>
:Author: Jonathan Karr <jonrkarr@gmail.com>
:Date: 2018-08-20
:Copyright: 2018, Karr Lab
:License: MIT
"""

from datetime import datetime
from pathlib import Path
import dateutil.parser
import docker
import io
import os
import re
import requests
import subprocess
import wc_env_manager.config.core


class WcEnvManagerError(Exception):
    """ Base class for exceptions in `wc_env_manager`

    Attributes:
        message (:obj:`str`): the exception's message
    """

    def __init__(self, message=None):
        super().__init__(message)


# todo: ensure that pytest and pytest-cov are installed by pip
# todo: clarify terminology for cloned & local WC/KarrLab repos
# todo: use configs_repo_pwd_file if ssh_key not available
# todo: use a regular user, not /root/: see 'Use USER' section of http://www.projectatomic.io/docs/docker-image-author-guidance/
# todo: replace CONTAINER_DEFAULTS with defaults in a config file
# todo: handle git branching; allow specification of branches as well as repos
# todo: make compatible with debuggers such as PyCharm
# todo: implement logging
CONTAINER_DEFAULTS = dict(
    ssh_key='~/.ssh/id_rsa_github',     # an ssh key that accesses karr_lab_repo_root, and doesn't need a passphrase
    configs_repo_username='karr-lab-daemon-public',
    git_config_file='assets/.gitconfig',
    bash_profile_file='assets/.bash_profile',
    container_repo_dir='/usr/git_repos',
    configs_repo_pwd_file='tokens/configs_repo_password',
    karr_lab_repo_root='https://github.com/KarrLab/',
    container_user_home_dir='/root/',
    container_local_repos='/usr/local_repos/',
)


class WcEnvManager(object):
    """ Manage computing environments (Docker containers) for whole-cell modeling

    Attributes:
        docker_image_repo (:obj:`str`): name of Docker image for environment
        docker_image_tags (:obj:`list` of :obj:`str`): list of tags for Docker repository
        dockerfile_path (:obj:`str`): path to Dockerfile for environment
        docker_image_build_args (:obj:`dict`): build argument for Dockerfile
        docker_image_context_path (:obj:`str`): path to context to build Docker image
        docker_container_name_format (:obj:`str`): format for timestamped names of Docker containers
            generated by :obj:`datetime.datetime.strftime`
        dockerhub_username (:obj:`str`): username for DockerHub
        dockerhub_password (:obj:`str`): password for DockerHub
        verbose (:obj:`bool`): if :obj:`True`, print status messages to stdout

        _docker_client (:obj:`docker.client.DockerClient`): client connected to the Docker daemon
        _docker_image (:obj:`docker.models.images.Image`): current Docker image
        _docker_container (:obj:`docker.models.containers.Container`): current Docker container


        local_wc_repos (:obj:`list` of `str`): directories of local KarrLab repos being modified
        container_repo_dir (:obj:`str`): pathname to dir containing mounted active repos
        container_user_home_dir (:obj:`str`): pathname to home dir of container user
        container_local_repos (:obj:`str`): pathname to dir in container with clones of KarrLab repos
        configs_repo_username (:obj:`str`): username for the private repo `KarrLab/karr_lab_config`
        configs_repo_pwd_file (:obj:`str`): password for the private repo `KarrLab/karr_lab_config`
        ssh_key (:obj:`str`): the path to a private ssh key file that can access GitHub;
            it cannot be protected by a passphrase
        git_config_file (:obj:`str`): a .gitconfig file that indicates how to access GitHub        
        container (:obj:`docker.models.containers.Container`): the Docker container being managed
        volumes (:obj:`dict`): the specification of the volumes used by the Docker container being managed
        container_name (:obj:`str`): name of the Docker container being managed
    """

    def __init__(self,
                 docker_image_repo=None, docker_image_tags=None,
                 dockerfile_path=None, docker_image_build_args=None, docker_image_context_path=None,
                 docker_container_name_format=None,
                 dockerhub_username=None, dockerhub_password=None,
                 verbose=False):
                 # local_wc_repos,
                 # container_repo_dir=CONTAINER_DEFAULTS['container_repo_dir'],
                 # container_user_home_dir=CONTAINER_DEFAULTS['container_user_home_dir'],
                 # container_local_repos=CONTAINER_DEFAULTS['container_local_repos'],
                 # configs_repo_username=CONTAINER_DEFAULTS['configs_repo_username'],
                 # configs_repo_pwd_file=CONTAINER_DEFAULTS['configs_repo_pwd_file'],
                 # ssh_key=CONTAINER_DEFAULTS['ssh_key'],
                 # git_config_file=CONTAINER_DEFAULTS['git_config_file']):
        """
        Args:
            docker_image_repo (:obj:`str`, optional): name of Docker repository for environment
            docker_image_tags (:obj:`list` of :obj:`str`, optional): list of tags for Docker repository
            dockerfile_path (:obj:`str`, optional): path to Dockerfile for environment
            docker_image_build_args (:obj:`dict`, optional): build argument for Dockerfile
            docker_image_context_path (:obj:`str`, optional): path to context to build Docker image
            docker_container_name_format (:obj:`str`, optional): format for timestamped names of Docker containers
                generated by :obj:`datetime.datetime.strftime`
            dockerhub_username (:obj:`str`, optional): username for DockerHub
            dockerhub_password (:obj:`str`, optional): password for DockerHub
            verbose (:obj:`bool`, optional): if :obj:`True`, print status messages to stdout


            local_wc_repos (:obj:`list` of `str`): directories of local KarrLab repos being modified
            container_repo_dir (:obj:`str`, optional): pathname to dir containing mounted active repos
            container_user_home_dir (:obj:`str`, optional): pathname to home dir of container user
            container_local_repos (:obj:`str`, optional): pathname to dir in container with clones of KarrLab repos
            configs_repo_username (:obj:`str`): username for the private repo `KarrLab/karr_lab_config`
            configs_repo_pwd_file (:obj:`str`): password for the private repo `KarrLab/karr_lab_config`
            ssh_key (:obj:`str`): the path to a private ssh key file that can access GitHub;
                it cannot be protected by a passphrase
            git_config_file (:obj:`str`): a .gitconfig file that indicates how to access GitHub

        Raises:
            :obj:`WcEnvManagerError`: if any local_wc_repos are not readable directories or are provided repeatedly
        """

        # get default configuration
        config = wc_env_manager.config.core.get_config()['wc_env_manager']

        # handle options
        self.docker_image_repo = docker_image_repo or config['docker_image_repo']
        self.docker_image_tags = docker_image_tags or config['docker_image_tags']
        self.dockerfile_path = dockerfile_path or config['dockerfile_path']
        self.docker_image_build_args = docker_image_build_args or config['docker_image_build_args']
        self.docker_image_context_path = docker_image_context_path or config['docker_image_context_path']
        self.docker_container_name_format = docker_container_name_format or config['docker_container_name_format']
        self.dockerhub_username = dockerhub_username or config['dockerhub_username']
        self.dockerhub_password = dockerhub_password or config['dockerhub_password']
        self.verbose = verbose

        # load Docker client
        self._docker_client = docker.from_env()
        self.set_docker_image(self.get_latest_docker_image())
        self.set_docker_container(self.get_latest_docker_container())

        """
        # resolve local_wc_repos as absolute paths
        self.local_wc_repos = []
        repo_names = set()
        errors = []
        for local_wc_repo_dir in local_wc_repos:
            path = os.path.abspath(os.path.expanduser(local_wc_repo_dir))
            # repo must be a readable directory
            if not(os.access(path, os.R_OK) and Path(path).is_dir()):
                errors.append("local WC repo dir '{}' is not a readable directory".format(path))
                continue
            # cannot have multiple repos with the same name
            repo_name = os.path.basename(path)
            if repo_name in repo_names:
                errors.append("repo '{}' appears multiple times in local_wc_repos".format(repo_name))
                continue
            repo_names.add(repo_name)
            self.local_wc_repos.append(path)
        if errors:
            raise WcEnvManagerError(', '.join(errors))

        self.container_repo_dir = container_repo_dir
        self.container_user_home_dir = container_user_home_dir
        self.container_local_repos = container_local_repos
        self.configs_repo_username = configs_repo_username
        self.configs_repo_pwd_file = configs_repo_pwd_file
        self.ssh_key = ssh_key
        self.git_config_file = git_config_file
        self.check_credentials()
        """

    def check_credentials(self):
        """ Validate the credentials needed in a Docker container for `wc_env_manager`

        Raises:
            :obj:`WcEnvManagerError`: if the credentials are incomplete or incorrect
        """
        # set attribute to None for credential files that don't exist
        credential_file_attrs = ['configs_repo_pwd_file', 'ssh_key', 'git_config_file']
        for attr in credential_file_attrs:
            file = getattr(self, attr)
            if file is None:
                continue
            path = os.path.abspath(os.path.expanduser(file))
            if Path(path).is_file():
                try:
                    open(path, 'r')
                    setattr(self, attr, path)
                except Exception:
                    setattr(self, attr, None)
            else:
                setattr(self, attr, None)

        # ensure that credentials are available
        if self.configs_repo_pwd_file is None and self.ssh_key is None:
            raise WcEnvManagerError("No credentials available: either an ssh key or the password "
                                    "to KarrLab/karr_lab_config must be provided.")

        # todo: test credentials against GitHub and the config repo

    def build_docker_image(self):
        """ Build Docker image for WC modeling environment

        Returns:
            :obj:`docker.models.images.Image`: Docker image
        """
        # build image
        if self.verbose:
            print('Building image {} with tags {{{}}} ...'.format(
                self.docker_image_repo, ', '.join(self.docker_image_tags)))

        if not os.path.isdir(self.docker_image_context_path):
            raise WcEnvManagerError('Docker image context "{}" must be a directory'.format(
                self.docker_image_context_path))

        with open(self.dockerfile_path, 'rb') as dockerfile:
            try:
                image, log = self._docker_client.images.build(
                    path=self.docker_image_context_path,
                    fileobj=dockerfile,
                    pull=True,
                    buildargs=self.docker_image_build_args,
                )
            except requests.exceptions.ConnectionError as exception:
                raise WcEnvManagerError("Docker connection error: service must be running:\n  {}".format(
                    str(exception).replace('\n', '\n  ')))
            except docker.errors.APIError as exception:
                raise WcEnvManagerError("Docker API error: Dockerfile contains syntax errors:\n  {}".format(
                    str(exception).replace('\n', '\n  ')))
            except docker.errors.BuildError as exception:
                raise WcEnvManagerError("Docker build error: Error building Dockerfile:\n  {}".format(
                    str(exception).replace('\n', '\n  ')))
            except Exception as exception:
                raise WcEnvManagerError("{}:\n  {}".format(
                    exception.__class__.__name__, str(exception).replace('\n', '\n  ')))

        # tag image
        for tag in self.docker_image_tags:
            image.tag(self.docker_image_repo, tag=tag)

        # re-get image because tags don't automatically update on image object
        image = self._docker_client.images.get('{}:{}'.format(self.docker_image_repo, self.docker_image_tags[0]))

        # print log
        if self.verbose:
            for entry in log:
                if 'stream' in entry:
                    print(entry['stream'], end='')
                elif 'id' in entry and 'status' in entry:
                    print('{}: {}'.format(entry['id'], entry['status']))
                else:
                    pass

        # store reference to latest image
        self._docker_image = image

        return image

    def remove_docker_image(self, force=False):
        """ Remove version of Docker image 
        Args:
            force (:obj:`bool`, optional): if :obj:`True`, force removal of the version of the
                image (e.g. even if a container with the image is running)
        """
        for tag in self.docker_image_tags:
            self._docker_client.images.remove('{}:{}'.format(self.docker_image_repo, tag), force=True)

    def login_dockerhub(self):
        """ Login to DockerHub """
        self._docker_client.login(self.dockerhub_username, password=self.dockerhub_password)

    def push_docker_image(self):
        """ Push Docker image to DockerHub """
        for tag in self.docker_image_tags:
            self._docker_client.images.push(self.docker_image_repo, tag)

    def pull_docker_image(self):
        """ Pull Docker image for WC modeling environment 

        Returns:
            :obj:`docker.models.images.Image`: Docker image
        """
        self._docker_image = self._docker_client.images.pull(self.docker_image_repo, tag=self.docker_image_tags[0])
        return self._docker_image

    def set_docker_image(self, image):
        """ Set the Docker image for WC modeling environment

        Args:
            image (:obj:`docker.models.images.Image` or :obj:`str`): Docker image 
                or name of Docker image
        """
        if isinstance(image, str):
            image = self._docker_client.images.get(image)
        self._docker_image = image

    def get_latest_docker_image(self):
        """ Get the lastest version of the Docker image for the WC modeling environment

        Returns:
            :obj:`docker.models.images.Image`: Docker image
        """
        try:
            return self._docker_client.images.get(self.docker_image_repo)
        except docker.errors.ImageNotFound:
            return None

    def get_docker_image_version(self):
        """ Get the version of the Docker image

        Returns:
            :obj:`str`: docker image version
        """
        for tag in self._docker_image.tags:
            _, _, version = tag.partition(':')
            if re.match(r'^\d+\.\d+\.\d+[a-zA-Z0-9]*$', version):
                return version

    def create_docker_container(self, tty=True):
        """ Create Docker container for WC modeling environmet

        Args:
            tty (:obj:`bool`): if :obj:`True`, allocate a pseudo-TTY           

        Returns:
            :obj:`docker.models.containers.Container`: Docker container
        """
        name = self.make_docker_container_name()
        container = self._docker_container = self._docker_client.containers.run(
            self.docker_image_repo, name=name,
            tty=tty, detach=True)
        return container

    def make_docker_container_name(self):
        """ Create a timestamped name for a Docker container

        Returns:
            :obj:`str`: container name
        """
        return datetime.now().strftime(self.docker_container_name_format)

    def setup_docker_container(self):
        # todo
        pass

    def set_docker_container(self, container):
        """ Set the Docker containaer

        Args:
            container (:obj:`docker.models.containers.Container` or :obj:`str`): Docker container
                or name of Docker container
        """
        if isinstance(container, str):
            container = self._docker_client.containers.get(container)
        self._docker_container = container

    def get_latest_docker_container(self):
        """ Get current Docker container

        Returns:
            :obj:`docker.models.containers.Container`: Docker container
        """
        containers = self.get_docker_containers(sort_by_read_time=True)
        if containers:
            return containers[0]
        else:
            return None

    def get_docker_containers(self, sort_by_read_time=False):
        """ Get list of Docker containers that are WC modeling environments

        Args:
            sort_by_read_time (:obj:`bool`): if :obj:`True`, sort by read time in descending order
                (latest first)

        Returns:
            :obj:`list` of :obj:`docker.models.containers.Container`: list of Docker containers 
                that are WC modeling environments
        """
        containers = []
        for container in self._docker_client.containers.list(all=True):
            try:
                datetime.strptime(container.name, self.docker_container_name_format)
                containers.append(container)
            except ValueError:
                pass

        if sort_by_read_time:
            containers.sort(reverse=True, key=lambda container: dateutil.parser.parse(container.stats(stream=False)['read']))

        return containers

    def get_docker_container_stats(self):
        """ Get statistics about the CPU, io, memory, network performance of the Docker container

        Returns:
            :obj:`dict`: statistics about the CPU, io, memory, network performance of the Docker container
        """
        return self._docker_container.stats(stream=False)

    def stop_docker_container(self):
        """ Remove current Docker container """
        self._docker_container.stop()

    def remove_docker_container(self, force=False):
        """ Remove current Docker container 

        Args:
            force (:obj:`bool`, optional): if :obj:`True`, force removal of the container
                (e.g. remove container even if it is running)
        """
        self._docker_container.remove(force=force)
        self._docker_container = None

    def remove_docker_containers(self, force=False):
        """ Remove Docker all containers that are WC modeling environments 

        Args:
            force (:obj:`bool`, optional): if :obj:`True`, force removal of the container
                (e.g. remove containers even if they are running)
        """
        for container in self.get_docker_containers():
            container.remove(force=force)
        self._docker_container = None

    def create(self, name=None):
        """ Create a Docker container for `wc_env_manager`

        Args:
            name (:obj:`str`, optional): the container's name; default provided by ``

        Returns:
            :obj:`docker.models.containers.Container`: the container created `make_container_name()`

        Raises:
            :obj:`docker.errors.APIError`: description of raised exceptions
        """
        # todo: after image stored on Hub: pull the Docker wc_env_manager image from Docker Hub
        self.container_name = name
        if name is None:
            self.container_name = self.make_container_name()

        # create the container that shares r/w access to local WC repos
        env_image = "karrlab/{}:{}".format(self.image_name, self.image_version)

        # todo: use pp_to_karr_lab_repos
        # mount wc repo directories in the container
        self.volumes = {}
        for local_wc_repo in self.local_wc_repos:
            local_wc_repo_basename = os.path.basename(local_wc_repo)
            container_wc_repo_dir = os.path.join(self.container_repo_dir, local_wc_repo_basename)
            self.volumes[local_wc_repo] = {'bind': container_wc_repo_dir, 'mode': 'rw'}

        try:
            if self.verbose:
                print("Running: containers.run({}, name='{}', etc.)".format(env_image, self.container_name))
            self.container = self.docker_client.containers.run(env_image, command='bash',
                                                               name=self.container_name,
                                                               volumes=self.volumes,
                                                               stdin_open=True,
                                                               tty=True,
                                                               detach=True)
        except requests.exceptions.ConnectionError as e:    # pragma: no cover     # tested by hand
            raise WcEnvManagerError("ConnectionError: Docker cannot run container: ensure that Docker is running: {}".format(e))
        except Exception as e:
            raise WcEnvManagerError("Error: cannot run container: {}".format(e))

        # load access credentials into the Docker container
        if self.ssh_key:
            self.cp(self.ssh_key, os.path.join(self.container_user_home_dir, '.ssh/id_rsa'))
            self.cp(self.ssh_key+'.pub', os.path.join(self.container_user_home_dir, '.ssh/id_rsa.pub'))
            cmd = "ssh-keyscan github.com >> {}".format(os.path.join(self.container_user_home_dir, '.ssh/known_hosts'))
            self.exec_run(cmd)

        if self.git_config_file:
            # copy a .gitconfig file into the home directory of root in the container
            self.cp(self.git_config_file, os.path.join(self.container_user_home_dir, '.gitconfig'))
        return self.container

    def load_karr_lab_tools(self):
        """ Use pip to install KarrLab pkg_utils and karr_lab_build_utils in the container

        Raises:
            :obj:`WcEnvManagerError`: if pip commands fail
        """
        major, minor, _ = self.python3_version.split('.')
        python_version_major_minor = "{}.{}".format(major, minor)
        print('pip install pkg_utils --')
        cmd = "pip{} install -U --process-dependency-links "\
            "git+https://github.com/KarrLab/pkg_utils.git#egg=pkg_utils".format(python_version_major_minor)
        self.exec_run(cmd)

        print('pip install karr_lab_build_utils --')
        cmd = "pip{} install -U --process-dependency-links "\
            "git+https://github.com/KarrLab/karr_lab_build_utils.git#egg=karr_lab_build_utils".format(
                python_version_major_minor)
        self.exec_run(cmd)

    def clone_karr_lab_repos(self):
        """ Use git to clone KarrLab GitHub repos into the container

        Raises:
            :obj:`WcEnvManagerError`: if mkdir or git commands fail
        """
        self.exec_run("mkdir {}".format(self.container_local_repos))
        for wc_repo in WcEnv.all_wc_repos():
            cmd = "git clone https://github.com/KarrLab/{}.git".format(wc_repo)
            self.exec_run(cmd, workdir=self.container_local_repos)

    def pp_to_karr_lab_repos(self):
        """ Create bash command to append KarrLab repos to `PYTHONPATH` in container

        Local KarrLab repos mounted on volumes come ahead of cloned KarrLab repos.

        Returns:
            :obj:`str`: `PYTHONPATH` export command
        """
        pythonpath = []
        # paths for mounted local wc_repos
        for local_wc_repo in self.local_wc_repos:
            local_wc_repo_basename = os.path.basename(local_wc_repo)
            pythonpath.append(os.path.join(self.container_repo_dir, local_wc_repo_basename))

        # paths for repos cloned into container
        for wc_repo in WcEnv.all_wc_repos():
            pythonpath.append(os.path.join(self.container_local_repos, wc_repo))

        rv = 'export PYTHONPATH="$PYTHONPATH:{}"'.format(':'.join(pythonpath))
        return rv

    def run(self):
        """ Run a Docker container for `wc_env_manager`

        Returns:
            :obj:`docker.models.containers.Container`: the running container
        """
        container = self.create()
        self.load_karr_lab_tools()
        self.clone_karr_lab_repos()
        # todo: copy a custom .bash_profile file into the container
        return container

    def use(self, arg_1, arg_2, kwarg_1=None, kwarg_2=None):
        """ Use an existing Docker container for `wc_env_manager`

        Args:
            arg_1 (:obj:`type of arg_1`): description of arg_1
            kwarg_1 (:obj:`type of kwarg_1`, optional): description of kwarg_1
            ...

        Returns:
            :obj:`type of return value`: description of return value

        Raises:
            :obj:`type of raised exception(s)`: description of raised exceptions
        """
        # step 1
        # step 2
        pass

    def refresh(self, arg_1, arg_2, kwarg_1=None, kwarg_2=None):
        """ Refresh a `wc_env_manager` Docker container

        Args:
            arg_1 (:obj:`type of arg_1`): description of arg_1
            kwarg_1 (:obj:`type of kwarg_1`, optional): description of kwarg_1
            ...

        Returns:
            :obj:`type of return value`: description of return value

        Raises:
            :obj:`type of raised exception(s)`: description of raised exceptions
        """
        # step 1
        # step 2
        pass

    # utility functions and methods
    def cp(self, path, dest_dir):
        """ Copy a file or directory into the `wc_env_manager` Docker container

        Use the command `docker cp path dest_dir` to copy path.

        Unfortunately, the Docker API currently (2018-04-09) lacks a cp command
        (see https://github.com/docker/docker-py/issues/1771). Alternatively, one could write a method
        that takes a path, builds a temporary tar archive and calls put_archive() to put the archive
        in the container. Code from the Docker API could be reused for that approach.

        Args:
            path (:obj:`str`): the path of a file or directory to copy into the container
            dest_dir (:obj:`str`): the container's directory which will store the copied file or directory

        Raises:
            :obj:`WcEnvManagerError`: if `path` does not exist or `container_name` has not been initialized
            :obj:`subprocess.CalledProcessError`: if 'docker cp' fails; see error conditions in the Docker documentation
        """
        # check path and self.container_name
        if not Path(path).exists():
            raise WcEnvManagerError("Error: path '{}' does not exist".format(path))
        if self.container_name is None or not self.container_name:
            raise WcEnvManagerError('Error: container_name not initialized')
        command = ['docker', 'cp', path, '{}:{}'.format(self.container_name, dest_dir)]
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        result.stdout = result.stdout.decode('utf-8')
        result.stderr = result.stderr.decode('utf-8')
        result.check_returncode()

    def exec_run(self, command, **kwargs):
        """ Run exec_run on a container

        Args:
            command (:obj:`str`): the command to have `exec_run` run
            kwargs (:obj:`dict`): keyword arguments for `exec_run`

        Returns:
            :obj:`str`: output of `exec_run`

        Raises:
            :obj:`WcEnvManagerError`: if `self.container.exec_run` fails
        """
        kws = ', '.join(['{}={}'.format(k, v) for k, v in kwargs.items()])
        if kws:
            kws = ', ' + kws
        if self.verbose:
            print("Running: container.exec_run({}{})".format(command, kws))
        exit_code, output = self.container.exec_run(command.split(), **kwargs)
        if exit_code != 0:
            raise WcEnvManagerError("{}:\nself.container.exec_run({}{}) receives exit_code {}".format(__file__,
                                                                                                      command, kws, exit_code))
        return output.decode('utf-8')

    @staticmethod
    def all_wc_repos():
        """ Get all WC repos

        Returns:
            :obj:`list` of `str`: list of names of all WC repos
        """
        # :todo: get these repos programatically
        ALL_WC_REPOS = 'wc_lang wc_sim wc_utils obj_model wc_kb kinetic_datanator wc_rules'
        return ALL_WC_REPOS.split()
